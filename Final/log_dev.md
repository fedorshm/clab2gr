
 Получил Задание
 
Задача глобальная: необходимо разработать детектор элементов документа по картинке
Подзадачи:
1. Создать генератор документов docx или pdf для получения обучающей выборки
2. Сформировать из документов набор данных - картинки и координатную разметку к ним
3. Обучить модель на этих данных

Перешёл к решению первой задачи
1. Создать генератор документов docx или pdf для получения обучающей выборки

Изучил требования к генератору 

 Документы должны содержать:
    - заголовки (на 2 и более размера крупнее основного текста, жирные и/или курсив, чаще с выравниванием по середине, возможно с нумерацией)
	- абзацы текста (с красной строки и без, шрифт от 8 до 16, различное выравнивание)
	- таблицы (с сеткой и без, левые-правые границы могут быть без сетки, цветные и черно-белые, различное выравнивание самой таблицы и ячеек внутри)
	- рисунки (любые картинки, графики, встроенные элементы)
	- подписи к рисункам (часто на 1-2 размера меньше, реже до и чаще после картинки, начинаются с "Рис. <номер>", "Рисунок <номер> -", "Рисунок <номер>", часто выравнивание по центру)
	- подписи к таблицам (такого же или на 1-2 размера меньше основного текста, перед таблицей, начинаются с "Табл. <номер>", "Таблица <номер> -", "Таблица. < без номера>")
    - нумерованные списки (у них обычно меньше межстрочный интервал и есть отступ)
	- маркированные списки (у них обычно меньше межстрочный интервал и есть отступ)
	- верхний и нижний колонтитулы (будет плюсом)
	- сноски (будет плюсом)
	- формулы (будет плюсом, если получится)
2. Должны быть примеры с несколькими колонками текста
3. Размер выборки 10 тыс. изображений.
4. Сохранить файлы в папку "docx".
5. 
Стал выбор в каком стиле выполнять первый пункт функциональном или ООП

Решил выполнять 1 пункт в функциональном стиле  тк не планируется какое-либо осложнение задачи и в данный момент в сжатые сроки. Из недостатков можно выделить некоторое количество повторения кода в нескольких функциях, но учитывая объём это не критично.  Возможно при наличии времени  стоит стоит будет реализовать в ооп. 

Для создания док файлов рассмотрел несколько вариантов библиотек, но остановился на предложенном задании python-docx


После определения функционального стиля и библиотеки сразу решил составить 100% нужных функция для создания:

1) Документа
2) Заголовка
3) Абзац текста
4) Таблицы
5) Рисунка
6) Подписи к рисунку
7) Подписи к таблицам
8) Нумерованные списки
9) Маркированные списки
10) Верхний колонтитула
11) Нижнего колонтитула
12) Сноски
13) Формулы

Далее для каждой функции решил внести требования из задания и свои требования
Для функции создания документа 
```python
def create_document()

```
Первым делом нужно создать объект типа Document() из библиотеки python-docx
```python
doc = Document()
```
Должны генерироваться документы в альбомной и портретной ориентации
Тк документы разной ориентации генерироваться одной функции значит нам нужно случайно делать выбор Соотвествено подключаем библиотеку рандом и в дальнейших случаях случайного выбора для выполнения условий и в дальнейшем увеличивая разнообразия для обучающей выборки будем применять её

Также из условий следует что у документа должен быть выбран основной размер текста 
от 8 до 16 Pt.  Решил при создании документа сразу выбирать основной текст и как параметр передавать его функциям внутри.     
```python
base_font_size = random.choice(range(8, 17))
```

После определения Размера основного текста передадим его в функции где он необходим

Также для добавления других элементов текста но не по одному шаблону а с разными вариациями решил функции вызвать в случайном порядке случайным образом. 

После добавления элемнтов будет необходимо сохранить файл тк для выборки в 10000 изображений потребуется много файлов логичнее всего все файлы сохранить в отдельную папку. Чтобы предотвратить ошибки Делаю проверка есть ли эта директория и если нет то создаю её. Файлы будем называть doc_индекс индекс от 0 и по количеству наших файлов. 

После первоначальной реализации генератора документов в виде одного большого скрипта я столкнулся с рядом проблем:

- **Читаемость кода**: Большой скрипт становится трудным для понимания и сопровождения, особенно когда он содержит множество функций и логики.
- **Повторение кода**: В большом скрипте легко упустить повторяющиеся фрагменты кода, что затрудняет их обновление и отладку.
- **Трудности в расширении функциональности**: Добавление новых функций требует больше времени и может привести к появлению ошибок, если код не структурирован должным образом.

Чтобы решить эти проблемы, я решил разбить один большой скрипт на несколько отдельных файлов (модулей), каждый из которых отвечает за определенную функциональность. Это соответствует принципам модульности и разделения ответственности. 

#### Структура файлов после разделения:

- **`main.py`**: Точка входа в программу. Содержит основную логику запуска генерации документов.
    
- **`config.py`**: Содержит настройки и конфигурационные данные, такие как частоты появления различных блоков и используемые языки.
    
- **`document.py`**: Основной модуль для создания документа. Содержит функции для добавления элементов в документ.
    
- **`generators.py`**: Содержит функции для генерации содержимого, такого как текст, таблицы, изображения и формулы.
    
- **`styles.py`**: Отвечает за применение стилей к элементам документа.
    
- **`utils.py`**: Вспомогательные функции, которые используются в разных частях проекта.
    
- **`annotations.py`**: Модуль для сохранения аннотаций и метаданных, связанных с документами.
    
- **`classify.py`**: Содержит функции для классификации блоков в документе.

от  annotations.py в дальнейшем отказался в связи с невозможностью получения координат генерируемых модулей. Пригодилось только для тестирования точности определения base_font_size для 2 этапа. 

 Детально разберём файлы из последней версии генератора
 
 ## Файл `config.py`
Этот файл содержит настройки частоты появления различных блоков в документе и определение используемых языков для генерации текста.

```python
from collections import OrderedDict

# Настройки частоты появления блоков для стандартного документа
block_frequencies = {
    'paragraph': 40,
    'table': 15,
    'picture': 15,
    'numbered_list': 10,
    'marked_list': 10,
    'formula': 10
}

# Языки для генерации данных
locales = OrderedDict([('en-US', 1), ('ru-RU', 2)])

```


- **Частота появления блоков:** Я решил установить вероятности появления различных типов блоков, чтобы документы были разнообразными и содержали достаточное количество каждого типа элементов.

- **Выбор языков:** Для генерации текста использую английский и русский языки, что помогает увеличить разнообразие данных и сделать модель более универсальной.

В дальнейшем возможно расширение что можно задать разные настройки частоты появления блоков для генерации  различных типов документов. К примеру инструкций,
финансовых отчетов, технической документации и т. д. .    

Также возможно расширение в плане языков документов. 

 ### `document.py`
```python
from docx import Document
from docx.shared import Pt, RGBColor, Inches
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.enum.table import WD_TABLE_ALIGNMENT
from docx.enum.section import WD_ORIENTATION
from docx.oxml.ns import qn
from docx.oxml import OxmlElement
import os
import random

from generators import generate_realistic_data, generate_formula_image, fake
from styles import apply_paragraph_format, apply_run_format, apply_title_format
from utils import roman_number, add_page_number, insert_footnote, to_superscript
from config import block_frequencies

def create_document(index):
    doc = Document()

    # Установка ориентации страницы
    section = doc.sections[0]
    if random.choice([True, False]):
        section.orientation = WD_ORIENTATION.LANDSCAPE
        section.page_width, section.page_height = section.page_height, section.page_width
    else:
        section.orientation = WD_ORIENTATION.PORTRAIT

    # Решение о многоколоночности документа
    is_multicolumn = random.choices([True, False], weights=[25, 75], k=1)[0]
    if is_multicolumn:
        main_table, num_columns = add_multicolumn_table(doc)
    else:
        main_table, num_columns = None, 1

    base_font_size = random.choice(range(8, 17))
    blocks = []
    footnotes = []

    # Добавление заголовка
    add_title(doc, base_font_size)
    blocks.append("title")

    # Добавление колонтитулов
    add_header(doc, base_font_size)
    blocks.append("header")
    add_footer(doc)
    blocks.append("footer")

    # Генерация содержимого документа
    num_blocks = random.randint(10, 20)
    block_types = list(block_frequencies.keys())
    weights = list(block_frequencies.values())
    current_column = 0

    for _ in range(num_blocks):
        block = random.choices(block_types, weights=weights, k=1)[0]
        if is_multicolumn:
            cell = main_table.rows[0].cells[current_column]
        else:
            cell = None

        if block == 'paragraph':
            add_paragraph(doc, base_font_size, footnotes, cell)
        elif block == 'table':
            add_table(doc, base_font_size, cell)
            if cell is not None:
                paragraph = cell.add_paragraph()
            else:
                paragraph = doc.add_paragraph()
        elif block == 'picture':
            add_picture(doc, base_font_size, cell)
        elif block == 'numbered_list':
            add_numbered_list(doc, base_font_size, cell)
        elif block == 'marked_list':
            add_marked_list(doc, base_font_size, cell)
        elif block == 'formula':
            add_formula(doc, base_font_size, cell)
        blocks.append(block)

        if is_multicolumn:
            current_column = (current_column + 1) % num_columns

    add_footnotes_section(doc, footnotes, base_font_size)

    # Сохранение документа
    output_dir = "docx"
    os.makedirs(output_dir, exist_ok=True)
    filename = os.path.join(output_dir, f"doc_{index}.docx")
    doc.save(filename)

    return filename, base_font_size

```


- **Многоколоночность:** Для реализации нескольких колонок в документе я использовал таблицу без границ, где каждая ячейка представляет собой колонку. Это позволило легко распределять содержимое по колонкам.
- **Разнообразие элементов:** При генерации содержимого документа я случайным образом выбираю тип блока и добавляю соответствующий элемент с различными вариациями в форматировании и содержимом.
### Функции добавления элементов
#### Добавление заголовка

```python
def add_title(doc, base_font_size):
    title_number = random.choice([True, False])
    title = doc.add_paragraph()
    run = title.add_run()

    title_text = fake.sentence(nb_words=random.randint(1, 100))
    if title_number:
        title_text = f"{random.randint(0, 101)}. {title_text}"

    run.text = title_text

    # Применение стилей заголовка
    apply_title_format(title, base_font_size)

```
- **Вариативность заголовков:** Заголовки могут содержать нумерацию или быть без неё, быть жирными, курсивными и иметь разное выравнивание.

- **Размер шрифта:** Заголовок делается на 2-5 пунктов больше основного размера шрифта.

#### Добавление параграфа

```python
def add_paragraph(doc, base_font_size, footnotes, cell=None):
    if cell is not None:
        paragraph = cell.add_paragraph()
    else:
        paragraph = doc.add_paragraph()

    # Генерация текста абзаца
    text = fake.text(max_nb_chars=random.randint(50, 1000))
    insert_footnote(paragraph, text, base_font_size, footnotes, footnote_per_page=5)

    # Форматирование абзаца
    apply_paragraph_format(paragraph, base_font_size)

    if paragraph.runs:
        run = paragraph.runs[0]
        apply_run_format(run, base_font_size)

```
- **Случайное форматирование:** Абзацы могут иметь или не иметь отступ первой строки, различные выравнивания и шрифты.
- **Добавление сносок:** С некоторой вероятностью в абзац вставляется сноска. Работа с XML-структурой предполагала создание специальных элементов `<w:footnoteReference>` и соответствующих записей в секции `<w:footnotes>`. Это требовало глубокого понимания внутреннего устройства DOCX-файла и могло привести к непредсказуемым результатам, если что-то будет сделано неправильно. Кроме того, `python-docx` не предоставляет прямых методов для работы со сносками. Чтобы не усложнять код, я решил реализовать сноски более простым способом — посредством имитации сносок. Это было достигнуто путем вставки небольшого числового символа (верхнего индекса) непосредственно в текст абзаца, а затем добавления соответствующего текста сноски в конце документа или в специальный 
#### Добавление таблицы
```python
def add_table(doc, base_font_size, cell=None):
    if cell is not None:
        add_table_caption(doc, base_font_size, cell)
        table = cell.add_table(rows=random.randint(3, 10), cols=random.randint(3, 7))
    else:
        add_table_caption(doc, base_font_size)
        table = doc.add_table(rows=random.randint(3, 10), cols=random.randint(3, 7))

    remove_table_borders(table)
    # ...

```
- **Размер:** Количество колонок и столбцов  выбирается случайно. 
- **Стили таблицы:** Таблицы могут быть с границами и без, с различным выравниванием и стилями.
- **Заполнение данных:** Я использовал функцию `generate_realistic_data` для заполнения ячеек таблицы реалистичными данными использовав библиотеку mimesis. 

#### Добавление рисунка

```python
def add_picture(doc, base_font_size, cell=None):
    location_signature_after = random.choices([True, False], weights=[0.7, 0.3], k=1)[0]
    image_folder = "Dataset_images"

    if os.path.isdir(image_folder):
        images = [f for f in os.listdir(image_folder) if f.endswith(('.png', '.jpg', '.jpeg'))]
        if images:
            image_path = os.path.join(image_folder, random.choice(images))

            if cell is not None:
                paragraph = cell.add_paragraph()
            else:
                paragraph = doc.add_paragraph()
            paragraph.alignment = WD_ALIGN_PARAGRAPH.CENTER
            run = paragraph.add_run()

            if not location_signature_after:
                add_picture_caption(doc, base_font_size, cell)

            # Добавление изображения с корректировкой размера
            # ...

            if location_signature_after:
                add_picture_caption(doc, base_font_size, cell)

```

- **Подписи к рисункам:** Подпись может располагаться до или после изображения, чаще после.
- **Масштабирование:** Для многоколоночных документов изображение масштабируется под ширину колонки.

## Файл `generators.py`

```python
from faker import Faker
from mimesis import Generic
from mimesis.enums import Locale
import random
import sympy as sp
import matplotlib.pyplot as plt
from io import BytesIO

fake = Faker(list(locales.keys()))
generic = Generic(Locale.RU)

def generate_realistic_data():
    # Генерация данных для таблиц
    data_type = random.choice(['name', 'date', 'number', 'address', 'company'])
    # ...

def generate_formula_image():
    # Генерация изображения формулы с помощью SymPy и Matplotlib
    # ...


```
Содержит функции для генерации содержимого, такого как реалистичные данные для таблиц и изображения формул.
- **Генерация данных для таблиц:** Используя библиотеки `faker` и `mimesis`, я генерирую различные типы данных для заполнения таблиц.
- **Генерация формул:** С помощью `sympy` и `matplotlib` создаю изображения случайных математических выражений для вставки в документ.


## Файл `styles.py`

```python
from docx.shared import Pt
from docx.enum.text import WD_ALIGN_PARAGRAPH
import random

def apply_paragraph_format(paragraph, base_font_size):
    # Применяет форматирование к параграфу
    # ...

def apply_run_format(run, base_font_size):
    # Применяет форматирование к тексту внутри параграфа
    # ...

def apply_title_format(paragraph, base_font_size):
    # Применяет форматирование к заголовку
    # ...


```

- **Разделение стилей от логики:** Вынесение стилей в отдельный файл упрощает управление форматированием и повышает читаемость кода.

- **Вариативность стилей:** В функциях применяются случайные выборы шрифтов, выравниваний и других параметров для увеличения разнообразия.

## Файл `utils.py`

```python
def roman_number(n):
    # Преобразует число в римскую цифру
    # ...

def to_superscript(number):
    # Преобразует число в верхний индекс
    # ...

def add_page_number(paragraph):
    # Добавляет номер страницы в нижний колонтитул
    # ...

def insert_footnote(paragraph, text, base_font_size, footnotes, footnote_per_page=5):
    # Вставляет сноску в текст
    # ...

```
- **Упрощение кода:** Вынесение часто используемых функций в отдельный файл помогает избежать дублирования и упрощает поддержку кода.
- **Форматирование сносок и номеров страниц:** Реализовал функции для корректного добавления сносок и номеров страниц в документ.

## Файл `main.py`

```python
from document import create_document

def main():
    for index in range(10000):
        filename, base_font_size = create_document(index)
        print(f"Сгенерирован документ: {filename}")

    print("Генерация документов завершена.")

if __name__ == "__main__":
    main()

```
- **Масштабирование генерации:** С помощью цикла генерирую необходимое количество документов для формирования выборки.
- **Логирование:** Вывожу сообщения о прогрессе генерации для удобства отслеживания процесса.
## Вывод
В результате я разработал генератор документов, который соответствует заданным требованиям и способен создавать разнообразные документы для последующей обработки и обучения модели. Код структурирован по модулям для удобства поддержки и расширения функциональности. При необходимости генератор можно доработать, добавив новые элементы или улучшив существующие. 

**Дальнейшие шаги:**
1. **Сформировать набор данных:** Используя сгенерированные документы, необходимо конвертировать их в PDF и извлечь из них изображения страниц и координатную разметку элементов.
2. **Обработать PDF-документы:** Написать скрипты для обработки PDF-файлов, выделения блоков текста, изображений и других элементов с их координатами.
3. **Обучить модель:** На основе полученных данных обучить модель детекции элементов документа по изображению.